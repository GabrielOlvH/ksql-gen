package dev.gabrielolv.kotsql.migration

import dev.gabrielolv.kotsql.schema.Migration
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant
import java.sql.Connection
import java.sql.SQLException

/**
 * Tracks migration history and state in the database.
 * Manages the migration_history table and provides migration status information.
 */
class MigrationTracker(private val connection: Connection) {
    
    companion object {
        private const val MIGRATION_TABLE = "kotsql_migration_history"
    }
    
    /**
     * Represents a migration record in the database
     */
    data class MigrationRecord(
        val id: Long,
        val name: String,
        val fromVersion: String,
        val toVersion: String,
        val appliedAt: Instant,
        val executionTimeMs: Long,
        val checksum: String,
        val isReversible: Boolean,
        val status: MigrationStatus
    )
    
    /**
     * Migration execution status
     */
    enum class MigrationStatus {
        PENDING,      // Migration is pending execution
        RUNNING,      // Migration is currently executing
        COMPLETED,    // Migration completed successfully
        FAILED,       // Migration failed during execution
        ROLLED_BACK   // Migration was rolled back
    }
    
    /**
     * Initialize the migration tracking system by creating the migration history table
     */
    fun initialize() {
        try {
            val createTableSql = """
                CREATE TABLE IF NOT EXISTS $MIGRATION_TABLE (
                  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      name VARCHAR(255) NOT NULL UNIQUE,
      from_version VARCHAR(100) NOT NULL,
      to_version VARCHAR(100) NOT NULL,
      applied_at TIMESTAMP NOT NULL,
      execution_time_ms BIGINT NOT NULL,
      checksum VARCHAR(64) NOT NULL,
      is_reversible BOOLEAN NOT NULL DEFAULT FALSE,
      status VARCHAR(20) NOT NULL DEFAULT 'COMPLETED'
                )
            """.trimIndent()
            
            connection.createStatement().use { statement ->
                statement.execute(createTableSql)
            }
            
        } catch (e: SQLException) {
            throw MigrationException("Failed to initialize migration tracking table", e)
        }
    }
    
    /**
     * Check if the migration table exists and create it if it doesn't
     */
    private fun ensureTableExists() {
        try {
            // Try a simple query to check if table exists
            val sql = "SELECT COUNT(*) FROM $MIGRATION_TABLE WHERE 1=0"
            connection.createStatement().use { statement ->
                statement.executeQuery(sql)
            }
        } catch (e: SQLException) {
            // Table doesn't exist, initialize it
            initialize()
        }
    }
    
    /**
     * Check if a migration has been applied
     */
    fun isMigrationApplied(migrationName: String): Boolean {
        ensureTableExists()
        return try {
            val sql = "SELECT COUNT(*) FROM $MIGRATION_TABLE WHERE name = ? AND status = 'COMPLETED'"
            connection.prepareStatement(sql).use { statement ->
                statement.setString(1, migrationName)
                val result = statement.executeQuery()
                result.next() && result.getInt(1) > 0
            }
        } catch (e: SQLException) {
            throw MigrationException("Failed to check migration status for: $migrationName", e)
        }
    }
    
    /**
     * Record the start of a migration execution
     */
    fun recordMigrationStart(migration: Migration): Long {
        ensureTableExists()
        return try {
            // First check if migration already exists in any state
            val existingCheckSql = "SELECT id, status FROM $MIGRATION_TABLE WHERE name = ?"
            var existingId: Long? = null
            var existingStatus: String? = null
            
            connection.prepareStatement(existingCheckSql).use { statement ->
                statement.setString(1, migration.name)
                val result = statement.executeQuery()
                if (result.next()) {
                    existingId = result.getLong("id")
                    existingStatus = result.getString("status")
                }
            }
            
            // If migration already exists, handle accordingly
            if (existingId != null) {
                when (existingStatus) {
                    "COMPLETED" -> {
                        throw MigrationException("Migration ${migration.name} is already completed")
                    }
                    "RUNNING" -> {
                        throw MigrationException("Migration ${migration.name} is already running")
                    }
                    "FAILED", "ROLLED_BACK" -> {
                        // Update existing failed/rolled back record to running
                        val updateSql = """
                            UPDATE $MIGRATION_TABLE 
                            SET status = 'RUNNING', applied_at = ?, checksum = ?
                            WHERE id = ?
                        """.trimIndent()
                        
                        connection.prepareStatement(updateSql).use { statement ->
                            statement.setTimestamp(1, java.sql.Timestamp.from(java.time.Instant.ofEpochSecond(migration.timestamp.epochSeconds)))
                            statement.setString(2, calculateChecksum(migration))
                            statement.setLong(3, existingId)
                            statement.executeUpdate()
                        }
                        
                        return existingId
                    }
                }
            }
            
            // Insert new migration record
            val sql = """
                INSERT INTO $MIGRATION_TABLE 
                (name, from_version, to_version, applied_at, execution_time_ms, checksum, is_reversible, status)
                VALUES (?, ?, ?, ?, ?, ?, ?, 'RUNNING')
            """.trimIndent()
            
            connection.prepareStatement(sql, java.sql.Statement.RETURN_GENERATED_KEYS).use { statement ->
                statement.setString(1, migration.name)
                statement.setString(2, migration.fromVersion)
                statement.setString(3, migration.toVersion)
                statement.setTimestamp(4, java.sql.Timestamp.from(java.time.Instant.ofEpochSecond(migration.timestamp.epochSeconds)))
                statement.setLong(5, 0) // Will be updated on completion
                statement.setString(6, calculateChecksum(migration))
                statement.setBoolean(7, migration.isReversible)
                
                statement.executeUpdate()
                
                val generatedKeys = statement.generatedKeys
                if (generatedKeys.next()) {
                    generatedKeys.getLong(1)
                } else {
                    throw MigrationException("Failed to get generated key for migration record")
                }
            }
        } catch (e: SQLException) {
            throw MigrationException("Failed to record migration start for: ${migration.name}", e)
        }
    }
    
    /**
     * Record successful completion of a migration
     */
    fun recordMigrationSuccess(migrationId: Long, executionTimeMs: Long) {
        try {
            val sql = "UPDATE $MIGRATION_TABLE SET status = 'COMPLETED', execution_time_ms = ? WHERE id = ?"
            connection.prepareStatement(sql).use { statement ->
                statement.setLong(1, executionTimeMs)
                statement.setLong(2, migrationId)
                statement.executeUpdate()
            }
        } catch (e: SQLException) {
            throw MigrationException("Failed to record migration success for ID: $migrationId", e)
        }
    }
    
    /**
     * Record migration failure
     */
    fun recordMigrationFailure(migrationId: Long, executionTimeMs: Long) {
        try {
            val sql = "UPDATE $MIGRATION_TABLE SET status = 'FAILED', execution_time_ms = ? WHERE id = ?"
            connection.prepareStatement(sql).use { statement ->
                statement.setLong(1, executionTimeMs)
                statement.setLong(2, migrationId)
                statement.executeUpdate()
            }
        } catch (e: SQLException) {
            throw MigrationException("Failed to record migration failure for ID: $migrationId", e)
        }
    }
    
    /**
     * Record migration rollback
     */
    fun recordMigrationRollback(migrationName: String) {
        try {
            val sql = "UPDATE $MIGRATION_TABLE SET status = 'ROLLED_BACK' WHERE name = ?"
            connection.prepareStatement(sql).use { statement ->
                statement.setString(1, migrationName)
                statement.executeUpdate()
            }
        } catch (e: SQLException) {
            throw MigrationException("Failed to record migration rollback for: $migrationName", e)
        }
    }
    
    /**
     * Get all applied migrations in chronological order
     */
    fun getAppliedMigrations(): List<MigrationRecord> {
        ensureTableExists()
        return try {
            val sql = "SELECT * FROM $MIGRATION_TABLE WHERE status = 'COMPLETED' ORDER BY applied_at ASC"
            connection.createStatement().use { statement ->
                val result = statement.executeQuery(sql)
                val migrations = mutableListOf<MigrationRecord>()
                
                while (result.next()) {
                    migrations.add(
                        MigrationRecord(
                            id = result.getLong("id"),
                            name = result.getString("name"),
                            fromVersion = result.getString("from_version"),
                            toVersion = result.getString("to_version"),
                            appliedAt = Instant.fromEpochSeconds(result.getTimestamp("applied_at").toInstant().epochSecond),
                            executionTimeMs = result.getLong("execution_time_ms"),
                            checksum = result.getString("checksum"),
                            isReversible = result.getBoolean("is_reversible"),
                            status = MigrationStatus.valueOf(result.getString("status"))
                        )
                    )
                }
                migrations
            }
        } catch (e: SQLException) {
            throw MigrationException("Failed to retrieve applied migrations", e)
        }
    }
    
    /**
     * Get pending migrations that need to be applied
     */
    fun getPendingMigrations(availableMigrations: List<Migration>): List<Migration> {
        val appliedMigrationNames = getAppliedMigrations().map { it.name }.toSet()
        return availableMigrations.filter { migration ->
            !appliedMigrationNames.contains(migration.name)
        }
    }
    
    /**
     * Get the current schema version (latest applied migration)
     */
    fun getCurrentSchemaVersion(): String? {
        ensureTableExists()
        return try {
            val sql = "SELECT to_version FROM $MIGRATION_TABLE WHERE status = 'COMPLETED' ORDER BY applied_at DESC LIMIT 1"
            connection.createStatement().use { statement ->
                val result = statement.executeQuery(sql)
                if (result.next()) {
                    result.getString("to_version")
                } else {
                    null
                }
            }
        } catch (e: SQLException) {
            throw MigrationException("Failed to get current schema version", e)
        }
    }
    
    /**
     * Get migration history summary
     */
    fun getMigrationSummary(): MigrationSummary {
        ensureTableExists()
        return try {
            val sql = """
                SELECT 
                    status,
                    COUNT(*) as count,
                    SUM(execution_time_ms) as total_time_ms,
                    AVG(execution_time_ms) as avg_time_ms
                FROM $MIGRATION_TABLE 
                GROUP BY status
            """.trimIndent()
            
            val statusCounts = mutableMapOf<MigrationStatus, Int>()
            var totalExecutionTime = 0L
            var totalMigrations = 0
            
            connection.createStatement().use { statement ->
                val result = statement.executeQuery(sql)
                while (result.next()) {
                    val status = MigrationStatus.valueOf(result.getString("status"))
                    val count = result.getInt("count")
                    val totalTime = result.getLong("total_time_ms")
                    
                    statusCounts[status] = count
                    totalExecutionTime += totalTime
                    totalMigrations += count
                }
            }
            
            MigrationSummary(
                totalMigrations = totalMigrations,
                completedMigrations = statusCounts[MigrationStatus.COMPLETED] ?: 0,
                failedMigrations = statusCounts[MigrationStatus.FAILED] ?: 0,
                rolledBackMigrations = statusCounts[MigrationStatus.ROLLED_BACK] ?: 0,
                totalExecutionTimeMs = totalExecutionTime,
                currentVersion = getCurrentSchemaVersion()
            )
            
        } catch (e: SQLException) {
            throw MigrationException("Failed to get migration summary", e)
        }
    }
    
    /**
     * Calculate checksum for migration integrity verification
     */
    private fun calculateChecksum(migration: Migration): String {
        val content = migration.upScript + migration.downScript
        return content.hashCode().toString(16).padStart(8, '0')
    }
    
    /**
     * Clean up old migration records (optional maintenance operation)
     */
    fun cleanupOldRecords(olderThanDays: Int) {
        try {
            val sql = "DELETE FROM $MIGRATION_TABLE WHERE applied_at < NOW() - INTERVAL ? DAY AND status IN ('COMPLETED', 'FAILED')"
            connection.prepareStatement(sql).use { statement ->
                statement.setInt(1, olderThanDays)
                val deletedCount = statement.executeUpdate()
                println("Cleaned up $deletedCount old migration records")
            }
        } catch (e: SQLException) {
            throw MigrationException("Failed to cleanup old migration records", e)
        }
    }
}

/**
 * Migration summary information
 */
data class MigrationSummary(
    val totalMigrations: Int,
    val completedMigrations: Int,
    val failedMigrations: Int,
    val rolledBackMigrations: Int,
    val totalExecutionTimeMs: Long,
    val currentVersion: String?
) {
    fun getSuccessRate(): Double {
        return if (totalMigrations > 0) {
            completedMigrations.toDouble() / totalMigrations.toDouble()
        } else {
            0.0
        }
    }
    
    fun getAverageExecutionTime(): Long {
        return if (totalMigrations > 0) {
            totalExecutionTimeMs / totalMigrations
        } else {
            0L
        }
    }
    
    override fun toString(): String {
        return buildString {
            appendLine("Migration Summary:")
            appendLine("  Total migrations: $totalMigrations")
            appendLine("  Completed: $completedMigrations")
            appendLine("  Failed: $failedMigrations")
            appendLine("  Rolled back: $rolledBackMigrations")
            appendLine("  Success rate: ${String.format("%.1f", getSuccessRate() * 100)}%")
            appendLine("  Total execution time: ${totalExecutionTimeMs}ms")
            appendLine("  Average execution time: ${getAverageExecutionTime()}ms")
            appendLine("  Current version: ${currentVersion ?: "None"}")
        }
    }
}

/**
 * Exception thrown during migration tracking operations
 */
class MigrationException(message: String, cause: Throwable? = null) : Exception(message, cause) 