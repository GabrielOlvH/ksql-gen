package dev.gabrielolv.kotsql.validation

import dev.gabrielolv.kotsql.model.SQLColumnInfo
import dev.gabrielolv.kotsql.model.SQLConstraint

/**
 * Maps SQL constraints to validation annotations for generated data classes.
 * Analyzes column metadata and determines appropriate validation annotations.
 */
object ValidationMapper {
    
    /**
     * Get all validation annotations for a column based on its SQL constraints
     */
    fun getValidationAnnotations(column: SQLColumnInfo): List<ValidationAnnotationInfo> {
        val annotations = mutableListOf<ValidationAnnotationInfo>()
        
        // Primary key annotation
        if (column.isPrimaryKey) {
            annotations.add(ValidationAnnotationInfo(
                name = "PrimaryKey",
                parameters = mapOf("autoGenerated" to hasAutoIncrement(column))
            ))
        }
        
        // Foreign key annotation
        if (column.isLikelyForeignKey) {
            column.referencedTableName?.let { refTable ->
                annotations.add(ValidationAnnotationInfo(
                    name = "ForeignKey",
                    parameters = mapOf(
                        "referencedTable" to "\"$refTable\"",
                        "referencedColumn" to "\"id\""
                    )
                ))
            }
        }
        
        // Not null validation (only for non-primary keys since PKs are implicitly non-null)
        if (!column.isNullable && !column.isPrimaryKey) {
            annotations.add(ValidationAnnotationInfo(
                name = "NotNull",
                parameters = mapOf("message" to "\"${column.columnName} cannot be null\"")
            ))
        }
        
        // String-specific validations
        if (isStringType(column.sqlType)) {
            addStringValidations(column, annotations)
        }
        
        // Numeric validations
        if (isNumericType(column.sqlType)) {
            addNumericValidations(column, annotations)
        }
        
        // Email validation for email-like column names
        if (isEmailColumn(column.columnName) && isStringType(column.sqlType)) {
            annotations.add(ValidationAnnotationInfo(
                name = "Email",
                parameters = mapOf("message" to "\"${column.columnName} must be a valid email address\"")
            ))
        }
        
        return annotations
    }
    
    /**
     * Add string-specific validation annotations
     */
    private fun addStringValidations(column: SQLColumnInfo, annotations: MutableList<ValidationAnnotationInfo>) {
        // Length validation based on VARCHAR size
        column.maxLength?.let { maxLength ->
            annotations.add(ValidationAnnotationInfo(
                name = "Length",
                parameters = mapOf(
                    "max" to maxLength.toString(),
                    "message" to "\"${column.columnName} must be at most $maxLength characters\""
                )
            ))
        }
        
        // NotBlank for required string fields
        if (!column.isNullable) {
            annotations.add(ValidationAnnotationInfo(
                name = "NotBlank",
                parameters = mapOf("message" to "\"${column.columnName} cannot be blank\"")
            ))
        }
        
        // Pattern validation for specific column types
        getPatternForColumn(column)?.let { pattern ->
            annotations.add(ValidationAnnotationInfo(
                name = "Pattern",
                parameters = mapOf(
                    "regex" to "\"${pattern.first}\"",
                    "message" to "\"${pattern.second}\""
                )
            ))
        }
    }
    
    /**
     * Add numeric validation annotations
     */
    private fun addNumericValidations(column: SQLColumnInfo, annotations: MutableList<ValidationAnnotationInfo>) {
        // Range validation for different numeric types
        val range = getNumericRange(column.sqlType)
        if (range != null) {
            if (isFloatingPointType(column.sqlType)) {
                annotations.add(ValidationAnnotationInfo(
                    name = "DecimalRange",
                    parameters = mapOf(
                        "min" to range.first.toString(),
                        "max" to range.second.toString(),
                        "message" to "\"${column.columnName} must be between ${range.first} and ${range.second}\""
                    )
                ))
            } else {
                annotations.add(ValidationAnnotationInfo(
                    name = "Range",
                    parameters = mapOf(
                        "min" to range.first.toLong().toString(),
                        "max" to range.second.toLong().toString(),
                        "message" to "\"${column.columnName} must be between ${range.first.toLong()} and ${range.second.toLong()}\""
                    )
                ))
            }
        }
    }
    
    /**
     * Check if column has auto increment
     */
    private fun hasAutoIncrement(column: SQLColumnInfo): Boolean {
        return column.constraints.any { 
            it is SQLConstraint.PrimaryKey && it.autoIncrement 
        }
    }
    
    /**
     * Check if SQL type is a string type
     */
    private fun isStringType(sqlType: String): Boolean {
        val normalizedType = sqlType.uppercase()
        return normalizedType.startsWith("VARCHAR") ||
                normalizedType.startsWith("CHAR") ||
                normalizedType.startsWith("TEXT") ||
                normalizedType.startsWith("CLOB") ||
                normalizedType.startsWith("NVARCHAR") ||
                normalizedType.startsWith("NCHAR")
    }
    
    /**
     * Check if SQL type is numeric
     */
    private fun isNumericType(sqlType: String): Boolean {
        val normalizedType = sqlType.uppercase()
        return normalizedType.startsWith("TINYINT") ||
                normalizedType.startsWith("SMALLINT") ||
                normalizedType.startsWith("INT") ||
                normalizedType.startsWith("BIGINT") ||
                normalizedType.startsWith("FLOAT") ||
                normalizedType.startsWith("DOUBLE") ||
                normalizedType.startsWith("DECIMAL") ||
                normalizedType.startsWith("NUMERIC") ||
                normalizedType.startsWith("REAL")
    }
    
    /**
     * Check if SQL type is floating point
     */
    private fun isFloatingPointType(sqlType: String): Boolean {
        val normalizedType = sqlType.uppercase()
        return normalizedType.startsWith("FLOAT") ||
                normalizedType.startsWith("DOUBLE") ||
                normalizedType.startsWith("DECIMAL") ||
                normalizedType.startsWith("NUMERIC") ||
                normalizedType.startsWith("REAL")
    }
    
    /**
     * Check if column name suggests it's an email field
     */
    private fun isEmailColumn(columnName: String): Boolean {
        val normalized = columnName.lowercase()
        return normalized.contains("email") || normalized.contains("mail")
    }
    
    /**
     * Get pattern validation for specific column types
     */
    private fun getPatternForColumn(column: SQLColumnInfo): Pair<String, String>? {
        val columnName = column.columnName.lowercase()
        
        return when {
            columnName.contains("phone") || columnName.contains("tel") -> {
                "^[+]?[0-9]{10,15}$" to "${column.columnName} must be a valid phone number"
            }
            columnName.contains("url") || columnName.contains("website") -> {
                "^https?://[\\w\\-]+(\\.[\\w\\-]+)+[/#?]?.*$" to "${column.columnName} must be a valid URL"
            }
            columnName.contains("username") -> {
                "^[a-zA-Z0-9_]{3,20}$" to "${column.columnName} must be 3-20 characters, letters, numbers, and underscores only"
            }
            else -> null
        }
    }
    
    /**
     * Get numeric range for SQL types
     */
    private fun getNumericRange(sqlType: String): Pair<Double, Double>? {
        val normalizedType = sqlType.uppercase()
        
        return when {
            normalizedType.startsWith("TINYINT") -> -128.0 to 127.0
            normalizedType.startsWith("SMALLINT") -> -32768.0 to 32767.0
            normalizedType.startsWith("INT") || normalizedType.startsWith("INTEGER") -> -2147483648.0 to 2147483647.0
            normalizedType.startsWith("BIGINT") -> -9223372036854775808.0 to 9223372036854775807.0
            normalizedType.startsWith("FLOAT") -> -Float.MAX_VALUE.toDouble() to Float.MAX_VALUE.toDouble()
            normalizedType.startsWith("DOUBLE") || normalizedType.startsWith("REAL") -> -Double.MAX_VALUE to Double.MAX_VALUE
            else -> null
        }
    }
}

/**
 * Represents a validation annotation to be applied to a property
 */
data class ValidationAnnotationInfo(
    val name: String,
    val parameters: Map<String, Any> = emptyMap()
) {
    /**
     * Generate the annotation string for code generation
     */
    fun toAnnotationString(): String {
        return if (parameters.isEmpty()) {
            "@$name"
        } else {
            val paramString = parameters.entries.joinToString(", ") { (key, value) ->
                "$key = $value"
            }
            "@$name($paramString)"
        }
    }
} 